/*   SPDX-License-Identifier: GPL-2.0
 *
 *  Driver for batradio hat on rpi zero.
 *     derived from Crystalfontz CFA-10049 FIQ handler
 *
 */

#include <linux/cdev.h>
#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/dma-mapping.h>
#include <linux/fs.h>
#include <linux/interrupt.h>
#include <linux/miscdevice.h>
#include <linux/mm.h>
#include <linux/mm_types.h>
#include <linux/module.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <linux/of_irq.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include <linux/string.h>
#include <linux/uaccess.h>

#include <linux/kernel.h>	/* Needed for KERN_INFO */

#include <asm/fiq.h>
#include <asm/pgtable.h>

#include "batradio.h"

struct bat_data {
  struct cdev	chrdev;
  dma_addr_t	dma;
  void __iomem	*fiq_base;
  unsigned int	irq;
  struct clk	*timer_clk;
  void __iomem	*timrot_base;
};
static struct bat_data *batradio_data;

extern unsigned char batradio_handler, batradio_handler_end;

static struct fiq_handler bat_fh = {
	.name	= "batradio_handler"
};

static int batradio_mmap(struct file *file, struct vm_area_struct *vma)
{
  struct fiq_buffer *fiq_buf = (struct fiq_buffer *)batradio_data->fiq_base;
  size_t size = vma->vm_end - vma->vm_start;
  unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;

  // ik begrijp het nog niet
  //  printk proberen
  if (offset + size > FIQ_BUFFER_SIZE)
    return -EINVAL;

  // __pa zou niet gebruikt mogen worden volgens memory.h
  offset += __pa(batradio_data->fiq_base);

  vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);

  /* Remap-pfn-range will mark the range VM_IO */
  // mm semaphore?
  if (remap_pfn_range(vma,
		      vma->vm_start,
		      offset >> PAGE_SHIFT,
		      size,
		      vma->vm_page_prot)) {
    return -EAGAIN;
  }

  fiq_buf->status = 0;

  return 0;
}

static long batradio_ioctl(struct file *file,
			       unsigned int cmd, unsigned long arg)
{
	struct fiq_buffer *fiq_buf = (struct fiq_buffer *)batradio_data->fiq_base;

	switch (cmd) {
	case FIQ_START:
		fiq_buf->status = FIQ_STATUS_RUNNING;
		//  ...
		break;
	case FIQ_STOP:
		fiq_buf->status = FIQ_STATUS_STOPPED;
		//  ...
		break;
	case FIQ_RESET:
		fiq_buf->status = FIQ_STATUS_STOPPED;
		//  ...
		break;
	default:
		return -ENOTTY;
	};

	return 0;
}

static const struct file_operations batradio_fops = {
	.mmap		= &batradio_mmap,
	.unlocked_ioctl	= &batradio_ioctl,
};

static struct miscdevice batradio_dev = {
	.name	= "batradio",
	.fops	= &batradio_fops,
	.minor	= MISC_DYNAMIC_MINOR,
};



/*


platform_get_resource
platform_get_irq




 */

static int bat_probe(struct platform_device *pdev)
{
  struct device_node *np;
  int ret;
  struct pt_regs regs;

  printk(KERN_INFO "Probe with bat_probe\n");
  return -9;
  
  np = pdev->dev.of_node;
  if (!np) {
    dev_err(&pdev->dev, "No device tree data available\n");
    return -EINVAL;
  }

  // wat krijg ik hier?
  batradio_data = devm_kzalloc(&pdev->dev,
			       sizeof(*batradio_data),
			       GFP_KERNEL);
  if (!batradio_data)
    return -ENOMEM;

  // hoe system timer 1 te selecteren?
  batradio_data->irq = irq_of_parse_and_map(np, 1);
  if (batradio_data->irq < 0) {
    dev_err(&pdev->dev, "Couldn't register given IRQ\n");
    return -EINVAL;
  }
  printk("irq: %d\n", batradio_data->irq);


  // wat moet er voor de system timer gebeuren?
  clk_prepare_enable(batradio_data->timer_clk);

  batradio_data->fiq_base = dma_zalloc_coherent(&pdev->dev,
						FIQ_BUFFER_SIZE,
						&batradio_data->dma,
						GFP_KERNEL);
  if (!batradio_data->fiq_base) {
    dev_err(&pdev->dev, "Couldn't allocate memory\n");
    return -ENOMEM;
  }

  dev_info(&pdev->dev,
	   "Allocated pages at address 0x%p, with size %dMB\n",
	   batradio_data->fiq_base, FIQ_BUFFER_SIZE >> 20);

  // how to setup system timer for fiq?

  ret = claim_fiq(&bat_fh);
  if (ret)
    return ret;

  set_fiq_handler(&batradio_handler,
		  &batradio_handler_end - &batradio_handler);

  // hoe registers te gebruiken?
  regs.ARM_r8 = (long)0;
  regs.ARM_r9 = (long)0;
  regs.ARM_r10 = (long)batradio_data->fiq_base;
  set_fiq_regs(&regs);

  /*  ergens opgepikt
    dout0 = ioremap(HW_PINCTRL_DOUT0, 0xffff);
    din0  = ioremap(HW_PINCTRL_DIN0, 0xffff);
    ...
    regs.ARM_r8 = (long) dout0;
    regs.ARM_r9 = (long) din0;
  */



  /* Enable the FIQ */
  // mxs_icoll_set_irq_fiq(batradio_data->irq);
  enable_fiq(batradio_data->irq);
  printk("Tot hier.\n");

  ret = misc_register(&batradio_dev);
	if (ret)
		return ret;

	return 0;
}

static int bat_remove(struct platform_device *pdev)
{
	return 0;
}

static const struct of_device_id bat_of_match[] = {
	{ .compatible = "raspberrypi,model-zero-w" },
	{}
};

static struct platform_driver bat_driver = {
	.probe	= bat_probe,
	.remove	= bat_remove,
	.driver = {
		.name = "batfiq",
		.of_match_table = of_match_ptr(bat_of_match),
		.owner = THIS_MODULE,
	},
};


int ourinitmodule(void)
{
    printk(KERN_INFO "  Welcome to sample Platform driver.... \n");

    /* Registering with Kernel */
    platform_driver_register(&bat_driver);

    return 0;
}

void ourcleanupmodule(void)
{
    printk(KERN_INFO "  Thanks....Exiting sample Platform driver... \n");

    /* Unregistering from Kernel */
    platform_driver_unregister(&bat_driver);

    return;
}

module_init(ourinitmodule);
module_exit(ourcleanupmodule);

// module_platform_driver(bat_driver);

MODULE_DESCRIPTION("FIQ handler for the batradio hat on RPI zero");
MODULE_AUTHOR("Sietse Achterop");
MODULE_LICENSE("GPL");
